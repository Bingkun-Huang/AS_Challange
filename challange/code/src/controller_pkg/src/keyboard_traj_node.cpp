#include <Eigen/Dense> // Requires Eigen library
#include <geometry_msgs/PoseStamped.h>
#include <geometry_msgs/Twist.h>
#include <iostream>
#include <math.h>
#include <nav_msgs/Odometry.h>
#include <ros/ros.h>
#include <tf/transform_broadcaster.h>
#include <trajectory_msgs/MultiDOFJointTrajectory.h>

#define PI M_PI

class TrajectoryPublisher {
public:
  TrajectoryPublisher()
      : linear_scale_(0.1), angular_scale_(0.1), is_initialized_(false),
        trajectory_duration_(5.0) {
    desired_state_pub_ =
        nh_.advertise<trajectory_msgs::MultiDOFJointTrajectory>("desired_state",
                                                                1);
    key_sub_ = nh_.subscribe("keyboard_input", 1,
                             &TrajectoryPublisher::keyboardCallback, this);
    current_pose_sub_ =
        nh_.subscribe("current_state_est", 1,
                      &TrajectoryPublisher::currentPoseCallback, this);
  }

  void run() {
    ros::Rate loop_rate(50); // 50Hz
    while (ros::ok()) {
      if (is_initialized_) {
        // Generate trajectory based on the current state and target position,
        // update desired_pose_ as the intermediate reference point on the
        // trajectory
        generateTrajectory();
        publishDesiredState();
        broadcastTransform(); // Publish TF transform
      }
      ros::spinOnce();
      loop_rate.sleep();
    }
  }

private:
  ros::NodeHandle nh_;
  ros::Publisher desired_state_pub_;
  ros::Subscriber key_sub_;
  ros::Subscriber current_pose_sub_;
  tf::TransformBroadcaster tf_broadcaster_;

  // desired_pose_ is the intermediate reference state generated by the current
  // trajectory, goal_pose_ is the target position set by keyboard input
  tf::Transform desired_pose_;
  tf::Transform goal_pose_;

  nav_msgs::Odometry current_pose_;
  double linear_scale_;
  double angular_scale_;
  bool is_initialized_;
  double trajectory_duration_; // Trajectory duration
  ros::Time trajectory_start_time_;

  // Keyboard input callback: Update target position and reset trajectory
  // planning start time
  void keyboardCallback(const geometry_msgs::Twist::ConstPtr &msg) {
    if (!is_initialized_)
      return;

    // Update goal_pose_ based on keyboard input (instead of directly modifying
    // desired_pose_)
    tf::Vector3 displacement(msg->linear.y * linear_scale_,
                             msg->linear.x * linear_scale_,
                             msg->linear.z * linear_scale_);
    tf::Vector3 new_goal = goal_pose_.getOrigin() + displacement;
    goal_pose_.setOrigin(new_goal);

    // Keep the target orientation unchanged, or update it as needed

    // Update the start time of trajectory planning
    trajectory_start_time_ = ros::Time::now();
  }

  // Current state callback: Initialize both desired_pose_ and goal_pose_ with
  // the current state
  void currentPoseCallback(const nav_msgs::Odometry &cur_state) {
    if (!is_initialized_) {
      // Initialize desired_pose_ and goal_pose_ with the current state
      tf::Vector3 current_position(cur_state.pose.pose.position.x,
                                   cur_state.pose.pose.position.y,
                                   cur_state.pose.pose.position.z);
      desired_pose_.setOrigin(current_position);
      goal_pose_.setOrigin(current_position);

      tf::Quaternion current_orientation;
      tf::quaternionMsgToTF(cur_state.pose.pose.orientation,
                            current_orientation);
      desired_pose_.setRotation(current_orientation);
      goal_pose_.setRotation(current_orientation);

      is_initialized_ = true;
      trajectory_start_time_ = ros::Time::now();
    }
    current_pose_ = cur_state;
  }

  // Generate current trajectory: Starting from the current state and ending at
  // goal_pose_, compute a smooth polynomial and generate the intermediate
  // desired state desired_pose_
  void generateTrajectory() {
    // Trajectory start point is the current measured position
    tf::Vector3 start_position(current_pose_.pose.pose.position.x,
                               current_pose_.pose.pose.position.y,
                               current_pose_.pose.pose.position.z);
    // End point is the position of goal_pose_
    tf::Vector3 end_position = goal_pose_.getOrigin();

    // Use 3rd-order polynomial planning: Constrain initial position, initial
    // velocity to 0, end position, end velocity to 0
    Eigen::MatrixXd A(4, 4);
    A << 1, 0, 0, 0, 0, 1, 0, 0, 1, trajectory_duration_,
        pow(trajectory_duration_, 2), pow(trajectory_duration_, 3), 0, 1,
        2 * trajectory_duration_, 3 * pow(trajectory_duration_, 2);
    Eigen::VectorXd b(4);
    // X-direction polynomial coefficients
    b << start_position.x(), 0.0, end_position.x(), 0.0;
    Eigen::VectorXd coeffs_x = A.inverse() * b;
    // Y-direction
    b << start_position.y(), 0.0, end_position.y(), 0.0;
    Eigen::VectorXd coeffs_y = A.inverse() * b;
    // Z-direction
    b << start_position.z(), 0.0, end_position.z(), 0.0;
    Eigen::VectorXd coeffs_z = A.inverse() * b;

    // Current time t relative to the trajectory start time
    double t = (ros::Time::now() - trajectory_start_time_).toSec();
    if (t > trajectory_duration_)
      t = trajectory_duration_;

    // Compute position based on the polynomial
    double x = coeffs_x(0) + coeffs_x(1) * t + coeffs_x(2) * pow(t, 2) +
               coeffs_x(3) * pow(t, 3);
    double y = coeffs_y(0) + coeffs_y(1) * t + coeffs_y(2) * pow(t, 2) +
               coeffs_y(3) * pow(t, 3);
    double z = coeffs_z(0) + coeffs_z(1) * t + coeffs_z(2) * pow(t, 2) +
               coeffs_z(3) * pow(t, 3);

    // Optional: Compute velocity and acceleration based on the polynomial (used
    // here only for message publishing)
    double vx = coeffs_x(1) + 2 * coeffs_x(2) * t + 3 * coeffs_x(3) * pow(t, 2);
    double vy = coeffs_y(1) + 2 * coeffs_y(2) * t + 3 * coeffs_y(3) * pow(t, 2);
    double vz = coeffs_z(1) + 2 * coeffs_z(2) * t + 3 * coeffs_z(3) * pow(t, 2);

    // Update desired_pose_ to the current reference state on the trajectory
    desired_pose_.setOrigin(tf::Vector3(x, y, z));
    // Here, the orientation of desired_pose_ can be kept unchanged, or smoothed
    // planning can be performed (this example keeps the original orientation)
  }

  // Publish desired_state message: Publish the current generated desired_pose_
  // along with computed velocity and acceleration
  void publishDesiredState() {
    trajectory_msgs::MultiDOFJointTrajectory msg;
    msg.header.stamp = ros::Time::now();
    msg.header.frame_id = "world";
    msg.joint_names.push_back("base_link");

    trajectory_msgs::MultiDOFJointTrajectoryPoint point;
    point.transforms.resize(1);

    // Set position and orientation
    point.transforms[0].translation.x = desired_pose_.getOrigin().x();
    point.transforms[0].translation.y = desired_pose_.getOrigin().y();
    point.transforms[0].translation.z = desired_pose_.getOrigin().z();
    point.transforms[0].rotation.x = desired_pose_.getRotation().getX();
    point.transforms[0].rotation.y = desired_pose_.getRotation().getY();
    point.transforms[0].rotation.z = desired_pose_.getRotation().getZ();
    point.transforms[0].rotation.w = desired_pose_.getRotation().getW();

    // Compute and set velocity (simple estimation: difference between target
    // and current state divided by duration)
    geometry_msgs::Twist velocity;
    velocity.linear.x =
        (goal_pose_.getOrigin().x() - current_pose_.pose.pose.position.x) /
        trajectory_duration_;
    velocity.linear.y =
        (goal_pose_.getOrigin().y() - current_pose_.pose.pose.position.y) /
        trajectory_duration_;
    velocity.linear.z =
        (goal_pose_.getOrigin().z() - current_pose_.pose.pose.position.z) /
        trajectory_duration_;
    velocity.angular.x = 0.0;
    velocity.angular.y = 0.0;
    velocity.angular.z = 0.0;
    point.velocities.push_back(velocity);

    // Compute and set acceleration (simple estimation: 2 times distance divided
    // by duration squared)
    geometry_msgs::Twist acceleration;
    acceleration.linear.x =
        2 * (goal_pose_.getOrigin().x() - current_pose_.pose.pose.position.x) /
        pow(trajectory_duration_, 2);
    acceleration.linear.y =
        2 * (goal_pose_.getOrigin().y() - current_pose_.pose.pose.position.y) /
        pow(trajectory_duration_, 2);
    acceleration.linear.z =
        2 * (goal_pose_.getOrigin().z() - current_pose_.pose.pose.position.z) /
        pow(trajectory_duration_, 2);
    acceleration.angular.x = 0.0;
    acceleration.angular.y = 0.0;
    acceleration.angular.z = 0.0;
    point.accelerations.push_back(acceleration);

    // Set desired completion time (from trajectory start to end)
    point.time_from_start = ros::Duration(trajectory_duration_);

    // Add the trajectory point to the message
    msg.points.push_back(point);

    // Publish the message
    desired_state_pub_.publish(msg);
  }

  // Publish TF transform: Publish desired_pose_ as the position of "av-desired"
  void broadcastTransform() {
    tf::StampedTransform transform;
    transform.setOrigin(desired_pose_.getOrigin());
    transform.setRotation(desired_pose_.getRotation());
    transform.stamp_ = ros::Time::now();
    transform.frame_id_ = "world";
    transform.child_frame_id_ = "av-desired";
    tf_broadcaster_.sendTransform(transform);
  }
};

int main(int argc, char **argv) {
  ros::init(argc, argv, "traj_pub_node");
  TrajectoryPublisher traj_publisher;
  traj_publisher.run();
  return 0;
}